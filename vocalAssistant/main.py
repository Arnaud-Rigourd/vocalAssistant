import json
import logging
import os
import subprocess
from functools import lru_cache
from pathlib import Path

import openai
import requests as requests
from dotenv import load_dotenv
from elevenlabs import generate, play
from tinydb import TinyDB

load_dotenv()

CUR_DIR = Path(__file__).resolve().parent

logging.basicConfig(
    level=logging.DEBUG,
    filename=f"{CUR_DIR}/app.log",
    filemode='a',
    format="%(asctime)s,%(msecs)d %(levelname)-8s [%(filename)s:%(lineno)d] %(message)s",
    datefmt='%Y-%m-%d %H:%M:%S',
)

db = TinyDB(f"{CUR_DIR}/history.json", indent=4)
chats = db.table("Chats")


def ask_chatbot(instructions: str, language: int) -> str:
    """
    Ask the chatbot a question and return the answer generated by the OpenAI API

    Args:
        instructions: The user prompt

    Returns:
        str: The response from the API
    """
    print("Thinking ðŸ¤”...")
    gpt_answer = interact_with_gpt(instructions, int(language))
    logging.debug("interact_with_GPT: success")
    print("Warming up the voice ðŸŽ¤...")
    _generate_audio_from_text(gpt_answer[6:]) if int(language) == 1 else _generate_french_voice(gpt_answer[6:])
    logging.debug("_generate_audio_from_text: success")
    return _get_remaining_characters()


@lru_cache
def _get_initial_gpt_prompt_for_english_answer() -> str:
    """
    Returns the initial prompt to send to the OpenAI API for english answers

    Returns:
        str: The initial prompt
    """
    initial_prompt = "Tu es un chatbot dont le rÃ´le est de m'assister dans mes problÃ©matiques quotidiennes. Tu es notamment spÃ©cialisÃ© sur le langage Python depuis plus de 20 ans et tu as une connaissance parfaite de toutes les librairies, modules et packages permettant d'optimiser les fonctions que tu me proposes pour rÃ©pondre Ã  mes demandes. Tu agis en tant que consultant perfectionniste et a pour but de toujours apporter la rÃ©ponse la plus prÃ©cise. Pour atteindre cet objectif, tu n'hÃ©sites pas Ã  me poser des questions si ma demande n'est pas assez claire pour que tu puisses y rÃ©pondre parfaitement. Je vais t'envoyer des prompts en franÃ§ais, je veux que tu me rÃ©pondes EN ANGLAIS Ã  chaque fois. Ne rÃ©ponds pas Ã  ce message qui a pour but de t'indiquer ton role. RÃ©ponds Ã  partir du prochain prompt qui te sera envoyÃ©. Tes rÃ©ponse ne doivent Ãªtres concises et ne doivent ABSOLUMENT PAS dÃ©passer les 10000 caractÃ¨res. Tu dois t'exprimer comme si nous discutions entre amis, la discution doit Ãªtre le plus naturelle possible."

    return initial_prompt


def _get_initial_gpt_prompt_for_french_answer():
    """
    Returns the initial prompt to send to the OpenAI API for french answers

    Returns:
        str: The initial prompt
    """
    initial_prompt = "Tu es un chatbot dont le rÃ´le est de m'assister dans mes problÃ©matiques quotidiennes. Tu es notamment spÃ©cialisÃ© sur le langage Python depuis plus de 20 ans et tu as une connaissance parfaite de toutes les librairies, modules et packages permettant d'optimiser les fonctions que tu me proposes pour rÃ©pondre Ã  mes demandes. Tu agis en tant que consultant perfectionniste et a pour but de toujours apporter la rÃ©ponse la plus prÃ©cise. Pour atteindre cet objectif, tu n'hÃ©sites pas Ã  me poser des questions si ma demande n'est pas assez claire pour que tu puisses y rÃ©pondre parfaitement. Ne rÃ©ponds pas Ã  ce message qui a pour but de t'indiquer ton role. RÃ©ponds Ã  partir du prochain prompt qui te sera envoyÃ©. Tes rÃ©ponse ne doivent Ãªtres concises et prÃ©cises. Tu dois t'exprimer comme si nous discutions entre amis, la discution doit Ãªtre le plus naturelle possible."

    return initial_prompt


def interact_with_gpt(instructions: str, language: int) -> str:
    """
    Send the user prompt to the OpenAI API and return the response

    Args:
        instructions: The user prompt

    Returns:
        str: The response from the API

    """
    openai.api_key = os.getenv("OPENAI_API_KEY")
    initial_prompt = ""

    if language == 1:
        initial_prompt = _get_initial_gpt_prompt_for_english_answer()
    elif language == 2:
        initial_prompt = _get_initial_gpt_prompt_for_french_answer()

    _insert_chats_into_db(initial_prompt, instructions)

    reply = _make_openai_api_request()

    return f"GPT : {reply}"


def _insert_chats_into_db(initial_prompt: str, instructions: str) -> None:
    """
    Insert the initial prompt and the user prompt into the database

    Args:
        initial_prompt: initial prompt to send to the OpenAI API to set the context
        instructions: The user prompt

    Returns:
        None: The database is updated
    """
    if chats:
        chats.insert({"role": "user", "content": instructions})
    else:
        chats.insert_multiple([
            {"role": "system", "content": initial_prompt},
            {"role": "user", "content": instructions},
        ])

    return None


def _make_openai_api_request() -> str:
    """
    Send the user prompt to the OpenAI API and return the response

    Returns:
        str: The response from the API
    """
    try:
        response = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",
            messages=chats.all(),
            temperature=1
        )
        logging.debug("interact_with_gpt(): Success")

    except requests.exceptions.RequestException as e:
        logging.error(f"interact_with_gpt(): Failed -> {e}")
        raise e.response.status_code

    else:
        reply = response['choices'][0]['message']['content']
        chats.insert({"role": "assistant", "content": reply})

    return reply


def _generate_audio_from_text(gpt_answer: str) -> None:
    """
    Generate an audio file using the Eleven Labs API

    Args:
        gpt_answer: The text generated by the OpenAI API

    Returns:
        None: The audio file is played in the current directory
    """
    try:
        audio = generate(
            text=gpt_answer,
            api_key=os.getenv('ELEVEN_API_KEY'),
            voice="Elli",
            model="eleven_monolingual_v1"
        )
        logging.debug("_generate_audio_from_text(): call to Eleven Labs API passed")
        print(gpt_answer)
        play(audio)

    except requests.exceptions.RequestException as e:
        logging.error("_generate_audio_from_text(): Call to Eleven Labs API failed")
        raise e.response.status_code

    return None


def _get_remaining_characters() -> str:
    """
    Get the number of remaining characters for the current month on the Eleven Labs API

    Returns:
        str: The number of remaining characters
    """
    headers = {
        "Accept": "application/json",
        "xi-api-key": os.getenv('ELEVEN_API_KEY')
    }

    response = _make_elevenlabs_api_request("https://api.elevenlabs.io/v1/user/subscription", **headers)
    remaining_characters: int = 10_000 - response["character_count"]

    return f"remaining characters: {remaining_characters}"


def _make_elevenlabs_api_request(url: str, **headers) -> json:
    """
    Make a request to the Eleven Labs API

    Args:
        url: The url to call
        **headers: The headers to send with the request

    Returns:
        json: The response from the API
    """
    try:
        response = requests.get(url, headers=headers)
        logging.debug("API request : Success")

    except requests.exceptions.RequestException as e:
        raise e.response.status_code

    return response.json()


def _generate_french_voice(gpt_answer: str) -> None:
    """
    Generate an audio file using the 'say' command in terminal

    Args:
        gpt_answer: The text generated by the OpenAI API

    Returns:
        None: The audio file is played in the current directory
    """
    print(gpt_answer)
    cmd = ['say', gpt_answer]
    subprocess.run(cmd)

    return None


if __name__ == '__main__':
    language = 0
    count = 0

    while int(language) not in [1, 2]:
        count += 1
        if count > 1:
            print("\nYour choice is incorrect, please try again.")
        language = input("Choose your language (type 1 or 2): \n1. English \n2. French \nYour choice: ")

    instructions = input("Parlez : ")
    while True:
        if "fin de la discussion" in instructions.lower():
            break
        remaining_characters = ask_chatbot(instructions, language)
        if int(language) == 1: print(remaining_characters)
        instructions = input("Parlez : ")

    chats.truncate()
